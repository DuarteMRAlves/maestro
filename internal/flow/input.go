package flow

import (
	"github.com/DuarteMRAlves/maestro/internal/errdefs"
)

// Input joins the input flows for a given stage and provides the next
// State to be processed.
type Input interface {
	Next() *State
}

// InputCfg represents the several input flows for a stage
type InputCfg struct {
	typ   InputType
	flows []*Flow
}

// InputType defines the type of input that the stage.Stage associated with this
// InputCfg is expecting.
type InputType string

const (
	// InputInfer means the input type is not specified and should be inferred
	// from the received connections.
	InputInfer InputType = "Infer"
	// InputSingle means the stage only receives input from another stage.
	InputSingle InputType = "Single"
	// InputSource means the stage is a source stage and receives as input an
	// empty message that should be generated by the orchestrator.
	InputSource InputType = "Source"
	// InputMerge means the input is a merge of multiple different messages,
	// coming from different stages.
	InputMerge InputType = "Merge"
	// InputCollect means the input collects from multiple stages, but the
	// received messages are all equal and should be directly sent to this
	// input stage.
	InputCollect InputType = "Collect"
)

func newInputCfg() *InputCfg {
	return &InputCfg{
		typ:   InputInfer,
		flows: []*Flow{},
	}
}

func (i *InputCfg) register(f *Flow) error {
	l := f.link
	// A previous link that consumes the entire message already exists
	if len(i.flows) == 1 && i.flows[0].link.TargetField() == "" {
		return errdefs.FailedPreconditionWithMsg(
			"link that receives the full message already exists")
	}
	for _, prev := range i.flows {
		if prev.link.TargetField() == l.TargetField() {
			return errdefs.InvalidArgumentWithMsg(
				"link with an equal name already registered: %s",
				l.Name())
		}
	}
	i.flows = append(i.flows, f)
	return nil
}

func (i *InputCfg) unregisterIfExists(search *Flow) {
	idx := -1
	for j, f := range i.flows {
		if f.link.Name() == search.link.Name() {
			idx = j
			break
		}
	}
	if idx != -1 {
		i.flows[idx] = i.flows[len(i.flows)-1]
		i.flows = i.flows[:len(i.flows)-1]
	}
}

func (i *InputCfg) ToInput() Input {
	switch len(i.flows) {
	case 1:
		return &SingleInput{flow: i.flows[0]}
	}
	return nil
}

// SingleInput is a struct the implements the Input for a single input
type SingleInput struct {
	flow *Flow
}

func (i *SingleInput) Next() *State {
	return i.flow.queue.Pop().(*State)
}
